<!doctype html>
<html>

<head>
	<meta charset="UTF-8">
	<title>analog keyboard overlay</title>
	<script type="module" src="browserInputOverlayView/default.js"></script>
	<link rel="stylesheet" href="browserInputOverlayView/_assets/style.css">
</head>

<body>

	<canvas id="canvas" width="1600" height="600" oncontextmenu="return false">
		Your browser does not support the HTML5 canvas tag.
	</canvas>
	<div id="propertyEditor" hidden oncontextmenu="return false">
		<p id="propertyEditorTitle">Window title text</p>
		<table id="propertyTable">
			<tr class="property">
				<td>fillStyle: </td>
				<td><input type="text" value="" class="inputBox fillStyle"></td>
			</tr>
		</table>
	</div>

	<!-- Bridge uiohook and native gamepad (XInput) to Web APIs (Electron only) -->
	<script>
		// Native XInput gamepad state (populated by main process polling)
		let xinputState = null;

		// Override navigator.getGamepads() to return XInput state when available
		if (window.electronAPI) {
			const originalGetGamepads = navigator.getGamepads.bind(navigator);

			navigator.getGamepads = function() {
				// If we have XInput data, convert it to Web Gamepad API format
				if (xinputState) {
					// Map XInput state to standard gamepad format
					// XInput: { LeftThumbstickX, LeftThumbstickY, RightThumbstickX, RightThumbstickY, LeftTrigger, RightTrigger, ... }
					// Web API: { axes: [leftX, leftY, rightX, rightY], buttons: [...] }

					const axes = [
						xinputState.LeftThumbstickX || 0,
						xinputState.LeftThumbstickY || 0,
						xinputState.RightThumbstickX || 0,
						xinputState.RightThumbstickY || 0
					];

					// Standard gamepad button mapping (17 buttons)
					// 0=A, 1=B, 2=X, 3=Y, 4=LB, 5=RB, 6=LT, 7=RT, 8=Back, 9=Start, 10=LS, 11=RS, 12=Up, 13=Down, 14=Left, 15=Right
					const buttons = [
						xinputState.A || false,
						xinputState.B || false,
						xinputState.X || false,
						xinputState.Y || false,
						xinputState.LeftShoulder || false,
						xinputState.RightShoulder || false,
						(xinputState.LeftTrigger || 0) > 0.1,  // Trigger as button
						(xinputState.RightTrigger || 0) > 0.1,
						xinputState.Back || false,
						xinputState.Start || false,
						xinputState.LeftThumb || false,  // Thumbstick click
						xinputState.RightThumb || false,
						xinputState.DPadUp || false,
						xinputState.DPadDown || false,
						xinputState.DPadLeft || false,
						xinputState.DPadRight || false,
						false  // Guide button (usually reserved)
					].map(pressed => ({ pressed, touched: pressed, value: pressed ? 1.0 : 0.0 }));

					return [
						{
							id: 'XInput Gamepad (STANDARD GAMEPAD)',
							index: 0,
							connected: true,
							timestamp: performance.now(),
							mapping: 'standard',
							axes: axes,
							buttons: buttons
						},
						null, null, null
					];
				}
				// Fallback to browser API when focused
				return originalGetGamepads();
			};

			// Listen for XInput state updates
			window.electronAPI.onGlobalGamepadState((state) => {
				xinputState = state;
			});

			console.log('[Renderer] ✓ XInput gamepad override active');
		}

		// TEST: Periodically log gamepad state
		console.log('[Renderer] Starting gamepad state monitor (logs every 2s)...');
		setInterval(() => {
			const pads = navigator.getGamepads();
			for (let i = 0; i < pads.length; i++) {
				if (pads[i]) {
					const axes = pads[i].axes.map(a => a.toFixed(2)).join(',');
					console.log('[Renderer] Gamepad', i, '- axes:[' + axes + '] - timestamp:', pads[i].timestamp);
				}
			}
		}, 2000);

		// uiohook keycode to KeyboardEvent.code mapping
		const UIOHOOK_TO_KEYCODE = {
			// Letters
			30: 'KeyA', 48: 'KeyB', 46: 'KeyC', 32: 'KeyD', 18: 'KeyE',
			33: 'KeyF', 34: 'KeyG', 35: 'KeyH', 23: 'KeyI', 36: 'KeyJ',
			37: 'KeyK', 38: 'KeyL', 50: 'KeyM', 49: 'KeyN', 24: 'KeyO',
			25: 'KeyP', 16: 'KeyQ', 19: 'KeyR', 31: 'KeyS', 20: 'KeyT',
			22: 'KeyU', 47: 'KeyV', 17: 'KeyW', 45: 'KeyX', 21: 'KeyY',
			44: 'KeyZ',
			// Numbers
			2: 'Digit1', 3: 'Digit2', 4: 'Digit3', 5: 'Digit4', 6: 'Digit5',
			7: 'Digit6', 8: 'Digit7', 9: 'Digit8', 10: 'Digit9', 11: 'Digit0',
			// Special keys
			57: 'Space', 28: 'Enter', 1: 'Escape', 14: 'Backspace',
			15: 'Tab', 42: 'ShiftLeft', 54: 'ShiftRight',
			29: 'ControlLeft', 97: 'ControlRight',
			56: 'AltLeft', 100: 'AltRight'
		};

		if (window.electronAPI) {
			console.log('[Renderer] ✓ electronAPI is available!');
			console.log('[Renderer] Has global input:', window.electronAPI.hasGlobalInput());
			console.log('[Renderer] Is readonly:', window.electronAPI.isReadonly());

			// Bridge uiohook events to synthetic DOM KeyboardEvents
			window.electronAPI.onGlobalKeyDown((data) => {
				console.log('[Renderer] IPC received keydown, keycode:', data.keycode);
				const code = UIOHOOK_TO_KEYCODE[data.keycode];
				if (code) {
					console.log('[Renderer] Dispatching synthetic keydown:', code);
					document.dispatchEvent(new KeyboardEvent('keydown', {
						code: code,
						bubbles: true,
						cancelable: true
					}));
				} else {
					console.warn('[Renderer] Unknown keycode:', data.keycode, '- add to mapping');
				}
			});

			window.electronAPI.onGlobalKeyUp((data) => {
				console.log('[Renderer] IPC received keyup, keycode:', data.keycode);
				const code = UIOHOOK_TO_KEYCODE[data.keycode];
				if (code) {
					console.log('[Renderer] Dispatching synthetic keyup:', code);
					document.dispatchEvent(new KeyboardEvent('keyup', {
						code: code,
						bubbles: true,
						cancelable: true
					}));
				}
			});

			console.log('[Renderer] ✓ Global input bridge active (uiohook → DOM events)');
		} else {
			console.log('[Renderer] ✗ electronAPI not found (running as web version)');
		}
	</script>
</body>

</html>
