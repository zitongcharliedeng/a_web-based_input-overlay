<!doctype html>
<html>

<head>
	<meta charset="UTF-8">
	<title>analog keyboard overlay</title>
	<!-- Cache-busting: increment version when updating code -->
	<script type="module" src="browserInputOverlayView/default.js?v=10"></script>
	<link rel="stylesheet" href="browserInputOverlayView/_assets/style.css?v=2">
</head>

<body>

	<canvas id="canvas" width="1600" height="600" oncontextmenu="return false">
		Your browser does not support the HTML5 canvas tag.
	</canvas>
	<div id="propertyEditor" hidden oncontextmenu="return false">
		<p id="propertyEditorTitle">Window title text</p>
		<table id="propertyTable">
			<tr class="property">
				<td>fillStyle: </td>
				<td><input type="text" value="" class="inputBox fillStyle"></td>
			</tr>
		</table>
	</div>

	<!-- Bridge uiohook and SDL to Web APIs (Electron only) -->
	<script>
		console.log('[Renderer] Script started');
		console.log('[Renderer] process.type:', typeof process !== 'undefined' ? process.type : 'undefined');
		console.log('[Renderer] window.electronAPI:', typeof window.electronAPI);

		// SDL gamepad state from main process (sdl2-gamecontroller)
		// sdl2-gamecontroller runs SDL_PumpEvents() in separate thread
		// This works with Electron's event loop and provides unfocused input
		let sdlGamepadState = null;
		const originalGetGamepads = navigator.getGamepads.bind(navigator);

		// Override navigator.getGamepads() to return SDL state if available
		navigator.getGamepads = function() {
			if (sdlGamepadState && sdlGamepadState.connected) {
				// Return SDL gamepad at index 0
				return [sdlGamepadState, null, null, null];
			}
			// Fallback to native Gamepad API (web version or no SDL)
			return originalGetGamepads();
		};

		// uiohook keycode to KeyboardEvent.code mapping
		const UIOHOOK_TO_KEYCODE = {
			// Letters
			30: 'KeyA', 48: 'KeyB', 46: 'KeyC', 32: 'KeyD', 18: 'KeyE',
			33: 'KeyF', 34: 'KeyG', 35: 'KeyH', 23: 'KeyI', 36: 'KeyJ',
			37: 'KeyK', 38: 'KeyL', 50: 'KeyM', 49: 'KeyN', 24: 'KeyO',
			25: 'KeyP', 16: 'KeyQ', 19: 'KeyR', 31: 'KeyS', 20: 'KeyT',
			22: 'KeyU', 47: 'KeyV', 17: 'KeyW', 45: 'KeyX', 21: 'KeyY',
			44: 'KeyZ',
			// Numbers
			2: 'Digit1', 3: 'Digit2', 4: 'Digit3', 5: 'Digit4', 6: 'Digit5',
			7: 'Digit6', 8: 'Digit7', 9: 'Digit8', 10: 'Digit9', 11: 'Digit0',
			// Special keys
			57: 'Space', 28: 'Enter', 1: 'Escape', 14: 'Backspace',
			15: 'Tab', 42: 'ShiftLeft', 54: 'ShiftRight',
			29: 'ControlLeft', 97: 'ControlRight',
			56: 'AltLeft', 100: 'AltRight'
		};

		if (window.electronAPI) {
			console.log('[Renderer] ✓ electronAPI is available!');
			console.log('[Renderer] Has global input:', window.electronAPI.hasGlobalInput());
			console.log('[Renderer] Is readonly:', window.electronAPI.isReadonly());

			// Bridge uiohook events to synthetic DOM KeyboardEvents
			window.electronAPI.onGlobalKeyDown((data) => {
				console.log('[Renderer] IPC received keydown, keycode:', data.keycode);
				const code = UIOHOOK_TO_KEYCODE[data.keycode];
				if (code) {
					console.log('[Renderer] Dispatching synthetic keydown:', code);
					document.dispatchEvent(new KeyboardEvent('keydown', {
						code: code,
						bubbles: true,
						cancelable: true
					}));
				} else {
					console.warn('[Renderer] Unknown keycode:', data.keycode, '- add to mapping');
				}
			});

			window.electronAPI.onGlobalKeyUp((data) => {
				console.log('[Renderer] IPC received keyup, keycode:', data.keycode);
				const code = UIOHOOK_TO_KEYCODE[data.keycode];
				if (code) {
					console.log('[Renderer] Dispatching synthetic keyup:', code);
					document.dispatchEvent(new KeyboardEvent('keyup', {
						code: code,
						bubbles: true,
						cancelable: true
					}));
				}
			});

			// Bridge SDL gamepad events to navigator.getGamepads()
			window.electronAPI.onGlobalGamepadState((state) => {
				console.log('[Renderer] SDL gamepad state update - axes:',
					state.axes.map(a => a.toFixed(2)).join(','),
					'- buttons:', state.buttons.filter(b => b.pressed).length, 'pressed');

				// Store state with proper Gamepad interface properties
				sdlGamepadState = {
					axes: state.axes,
					buttons: state.buttons,
					connected: state.connected,
					timestamp: state.timestamp,
					id: 'SDL2 Gamepad (sdl2-gamecontroller)',
					index: 0,
					mapping: 'standard'
				};
			});

			// Bridge uiohook mouse events to mouse state object
			window.electronAPI.onGlobalMouseDown((data) => {
				console.log('[Renderer] IPC received mousedown, button:', data.button);
				// Convert uiohook button values (1-5) to standard values (0-4)
				// uiohook: 1=Left, 2=Right, 3=Middle, 4=Back, 5=Forward
				// standard: 0=Left, 1=Middle, 2=Right, 3=Back, 4=Forward
				const buttonMap = { 1: 0, 3: 1, 2: 2, 4: 3, 5: 4 };
				const button = buttonMap[data.button];

				if (button !== undefined && window.mouse && window.mouse.buttons) {
					if (window.mouse.buttons[button] === false) {
						window.mouse.buttons[button] = true;
						window.mouse.clicks[button] = true;
						console.log('[Renderer] Updated mouse.buttons[' + button + '] = true');
					}
				}
			});

			window.electronAPI.onGlobalMouseUp((data) => {
				console.log('[Renderer] IPC received mouseup, button:', data.button);
				const buttonMap = { 1: 0, 3: 1, 2: 2, 4: 3, 5: 4 };
				const button = buttonMap[data.button];

				if (button !== undefined && window.mouse && window.mouse.buttons) {
					if (window.mouse.buttons[button] === true) {
						window.mouse.buttons[button] = false;
						console.log('[Renderer] Updated mouse.buttons[' + button + '] = false');
					}
				}
			});

			window.electronAPI.onGlobalMouseMove((data) => {
				// Update position (for future velocity tracking)
				if (window.mouse) {
					window.mouse.x = data.x;
					window.mouse.y = data.y;
				}
			});

			window.electronAPI.onGlobalWheel((data) => {
				console.log('[Renderer] IPC received wheel, rotation:', data.rotation);
				// Update wheel delta
				if (window.mouse && window.mouse.wheelDelta) {
					// rotation: positive = up, negative = down
					window.mouse.wheelDelta.y = data.rotation;
					console.log('[Renderer] Updated mouse.wheelDelta.y =', data.rotation);
				}
				// Set single-frame wheel events
				if (window.mouse && window.mouse.wheelEvents) {
					if (data.rotation > 0) {
						window.mouse.wheelEvents.up = true;
					} else if (data.rotation < 0) {
						window.mouse.wheelEvents.down = true;
					}
				}
			});

			console.log('[Renderer] ✓ Global input bridge active (uiohook + SDL → DOM/Web APIs)');
		} else {
			console.log('[Renderer] ✗ electronAPI not found (running as web version)');
		}
	</script>
</body>

</html>
